var t,e=t=>{if(t.__stencil__getHostRef)return t.__stencil__getHostRef()},n=(t,e)=>(0,console.error)(t,e),o="undefined"!=typeof window?window:{},r=o.HTMLElement||class{},l={t:0,o:"",jmp:t=>t(),raf:t=>requestAnimationFrame(t),ael:(t,e,n,o)=>t.addEventListener(e,n,o),rel:(t,e,n,o)=>t.removeEventListener(e,n,o),ce:(t,e)=>new CustomEvent(t,e)},s=!!(()=>{try{return!!o.document.adoptedStyleSheets&&(new CSSStyleSheet,"function"==typeof(new CSSStyleSheet).replaceSync)}catch(t){}return!1})()&&(()=>!!o.document&&Object.getOwnPropertyDescriptor(o.document.adoptedStyleSheets,"length").writable)(),i=!1,c=[],a=[],u=(t,e)=>n=>{t.push(n),i||(i=!0,e&&4&l.t?p(d):l.raf(d))},f=t=>{for(let e=0;e<t.length;e++)try{t[e](performance.now())}catch(t){n(t)}t.length=0},d=()=>{f(c),f(a),(i=c.length>0)&&l.raf(d)},p=t=>Promise.resolve(undefined).then(t),h=u(a,!0),m=t=>{const e=new URL(t,l.o);return e.origin!==o.location.origin?e.href:e.pathname},$=t=>l.o=t;function y(){const e=this.attachShadow({mode:"open"});void 0===t&&(t=null),t&&(s?e.adoptedStyleSheets.push(t):e.adoptedStyleSheets=[...e.adoptedStyleSheets,t])}var w,v=new WeakMap,b=(t,e,...n)=>{let o=null,r=null,l=!1,s=!1;const i=[],c=e=>{for(let r=0;r<e.length;r++)o=e[r],Array.isArray(o)?c(o):null!=o&&"boolean"!=typeof o&&((l="function"!=typeof t&&!("object"==(n=typeof(n=o))||"function"===n))&&(o=String(o)),l&&s?i[i.length-1].l+=o:i.push(l?g(null,o):o),s=l);var n};if(c(n),e){e.key&&(r=e.key);{const t=e.className||e.class;t&&(e.class="object"!=typeof t?t:Object.keys(t).filter((e=>t[e])).join(" "))}}const a=g(t,null);return a.i=e,i.length>0&&(a.u=i),a.p=r,a},g=(t,e)=>({t:0,h:t,l:null!=e?e:null,m:null,u:null,i:null,p:null}),S={},j=(t,e,n,o)=>{if(n!==o&&(e.toLowerCase(),"class"===e)){const e=t.classList,r=M(n);let l=M(o);e.remove(...r.filter((t=>t&&!l.includes(t)))),e.add(...l.filter((t=>t&&!r.includes(t))))}},k=/\s/,M=t=>("object"==typeof t&&t&&"baseVal"in t&&(t=t.baseVal),t&&"string"==typeof t?t.split(k):[]),O=(t,e)=>{const n=11===e.m.nodeType&&e.m.host?e.m.host:e.m,o=t&&t.i||{},r=e.i||{};for(const t of(l=Object.keys(r)).includes("ref")?[...l.filter((t=>"ref"!==t)),"ref"]:l)j(n,t,o[t],r[t]);var l},E=(t,e,n)=>{const r=e.u[n];let l,s,i=0;if(null!=r.l)l=r.m=o.document.createTextNode(r.l);else{if(!o.document)throw new Error("You are trying to render a Stencil component in an environment that doesn't support the DOM.");if(l=r.m=o.document.createElement(r.h),O(null,r),r.u){const e="template"===r.h?l.content:l;for(i=0;i<r.u.length;++i)s=E(t,r,i),s&&e.appendChild(s)}}return l["s-hn"]=w,l},C=(t,e,n)=>t.__insertBefore?t.__insertBefore(e,n):null==t?void 0:t.insertBefore(e,n),_=(t,e,n=!1)=>{const o=t.$hostElement$,r=t.$||g(null,null);var l;const s=(l=e)&&l.h===S?e:b(null,null,e);if(w=o.tagName,n&&s.i)for(const t of Object.keys(s.i))o.hasAttribute(t)&&!["key","ref","style","class"].includes(t)&&(s.i[t]=o[t]);s.h=null,s.t|=4,t.$=s,s.m=r.m=o.shadowRoot||o,((t,e)=>{const n=e.m=t.m,o=e.u,r=e.l;null==r?(O(t,e),null!==o&&((t,e,n,o,r,l)=>{let s,i=t;for(i.shadowRoot&&i.tagName===w&&(i=i.shadowRoot),"template"===n.h&&(i=i.content);r<=l;++r)o[r]&&(s=E(null,n,r),s&&(o[r].m=s,C(i,s,null)))})(n,0,e,o,0,o.length-1)):t.l!==r&&(n.data=r)})(r,s)},x=(t,e)=>{if(e&&!t.v&&e["s-p"]){const n=e["s-p"].push(new Promise((o=>t.v=()=>{e["s-p"].splice(n-1,1),o()})))}},P=(t,e)=>{if(4&t.t)return void(t.t|=512);x(t,t.S);const n=()=>U(t,e);if(!e)return h(n);queueMicrotask((()=>{n()}))},U=(t,e)=>{const n=t.$hostElement$,o=n;if(!o)throw new Error(`Can't render component <${n.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`);let r;return r=q(o,e?"componentWillLoad":"componentWillUpdate",void 0,n),r=D(r,(()=>q(o,"componentWillRender",void 0,n))),D(r,(()=>R(t,o,e)))},D=(t,e)=>L(t)?t.then(e).catch((t=>{console.error(t),e()})):e(),L=t=>t instanceof Promise||t&&t.then&&"function"==typeof t.then,R=async(t,e,n)=>{var o;const r=t.$hostElement$,l=r["s-rc"];W(t,e,r,n),l&&(l.map((t=>t())),r["s-rc"]=void 0);{const e=null!=(o=r["s-p"])?o:[],n=()=>A(t);0===e.length?n():(Promise.all(e).then(n).catch(n),t.t|=4,e.length=0)}},W=(t,e,o,r)=>{try{e=e.render(),_(t,e,r)}catch(e){n(e,t.$hostElement$)}return null},A=t=>{const e=t.$hostElement$,n=e,o=t.S;q(n,"componentDidRender",void 0,e),64&t.t?q(n,"componentDidUpdate",void 0,e):(t.t|=64,F(e),q(n,"componentDidLoad",void 0,e),t.j(e),o||V()),t.v&&(t.v(),t.v=void 0),512&t.t&&p((()=>P(t,!1))),t.t&=-517},V=()=>{p((()=>(t=>{const e=l.ce("appload",{detail:{namespace:"testautoloader"}});return t.dispatchEvent(e),e})(o)))},q=(t,e,o,r)=>{if(t&&t[e])try{return t[e](o)}catch(t){n(t,r)}},F=t=>t.classList.add("hydrated"),H=(t,o)=>{const r={t:o[0],k:o[1]};try{const o=t.prototype.connectedCallback,s=t.prototype.disconnectedCallback;return Object.assign(t.prototype,{__hasHostListenerAttached:!1,__registerHost(){((t,e)=>{const n={t:0,$hostElement$:t,M:e,O:new Map,C:new Map};n._=new Promise((t=>n.j=t)),t["s-p"]=[],t["s-rc"]=[];const o=n;t.__stencil__getHostRef=()=>o})(this,r)},connectedCallback(){if(!this.__hasHostListenerAttached){if(!e(this))return;this.__hasHostListenerAttached=!0}(t=>{if(!(1&l.t)){const o=e(t);if(!o)return;const r=()=>{};if(1&o.t)(null==o?void 0:o.P)||(null==o?void 0:o._)&&o._.then((()=>{}));else{o.t|=1;{let e=t;for(;e=e.parentNode||e.host;)if(e["s-p"]){x(o,o.S=e);break}}(async(t,e)=>{try{32&e.t||(e.t|=32,customElements.whenDefined(t.localName).then((()=>e.t|=128)));const n=e.S,o=()=>P(e,!0);n&&n["s-rc"]?n["s-rc"].push(o):o()}catch(o){n(o,t),e.v&&(e.v(),e.v=void 0),e.j&&e.j(t)}})(t,o)}r()}})(this),o&&o.call(this)},disconnectedCallback(){(async t=>{1&l.t||e(t),v.has(t)&&v.delete(t),t.shadowRoot&&v.has(t.shadowRoot)&&v.delete(t.shadowRoot)})(this),s&&s.call(this)},__attachShadow(){if(this.shadowRoot){if("open"!==this.shadowRoot.mode)throw new Error(`Unable to re-use existing shadow root for ${r.k}! Mode is set to ${this.shadowRoot.mode} but Stencil only supports open shadow roots.`)}else y.call(this,r)}}),Object.defineProperty(t,"is",{value:r.k,configurable:!0}),t}catch(e){return n(e),t}},z=t=>l.U=t,N=t=>Object.assign(l,t);function Y(t,e){_({$hostElement$:e},t)}function B(t){return t}export{r as H,z as a,N as b,m as g,b as h,H as p,Y as r,$ as s,B as t}