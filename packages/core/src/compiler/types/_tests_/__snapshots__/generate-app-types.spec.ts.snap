// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`generateAppTypes > attr: and prop: prefix generation > should not generate attr: or prop: prefixes for props without attributes 1`] = `
"/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/runtime";
export namespace Components {
    /**
     * docs
     */
    interface MyComponent {
        "internalData": InternalDataType;
    }
}
declare global {
    /**
     * docs
     */
    interface HTMLMyComponentElement extends Components.MyComponent, HTMLStencilElement {
    }
    var HTMLMyComponentElement: {
        prototype: HTMLMyComponentElement;
        new (): HTMLMyComponentElement;
    };
    interface HTMLElementTagNameMap {
        "my-component": HTMLMyComponentElement;
    }
}
declare namespace LocalJSX {
    /**
     * docs
     */
    interface MyComponent {
        "internalData"?: InternalDataType;
    }
    interface IntrinsicElements {
        "my-component": MyComponent;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * docs
             */
            "my-component": LocalJSX.IntrinsicElements["my-component"] & JSXBase.HTMLAttributes<HTMLMyComponentElement>;
        }
    }
}
"
`;

exports[`generateAppTypes > custom event types > should generate a type declaration file with custom event types 1`] = `
"/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/runtime";
import { UserImplementedEventType } from "./some/stubbed/path/resources";
export { UserImplementedEventType } from "./some/stubbed/path/resources";
export namespace Components {
    /**
     * docs
     */
    interface MyComponent {
    }
}
export interface MyComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMyComponentElement;
}
declare global {
    interface HTMLMyComponentElementEventMap {
        "myEvent": UserImplementedEventType;
    }
    /**
     * docs
     */
    interface HTMLMyComponentElement extends Components.MyComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMyComponentElementEventMap>(type: K, listener: (this: HTMLMyComponentElement, ev: MyComponentCustomEvent<HTMLMyComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMyComponentElementEventMap>(type: K, listener: (this: HTMLMyComponentElement, ev: MyComponentCustomEvent<HTMLMyComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMyComponentElement: {
        prototype: HTMLMyComponentElement;
        new (): HTMLMyComponentElement;
    };
    interface HTMLElementTagNameMap {
        "my-component": HTMLMyComponentElement;
    }
}
declare namespace LocalJSX {
    /**
     * docs
     */
    interface MyComponent {
        "onMyEvent"?: (event: MyComponentCustomEvent<UserImplementedEventType>) => void;
    }
    interface IntrinsicElements {
        "my-component": MyComponent;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * docs
             */
            "my-component": LocalJSX.IntrinsicElements["my-component"] & JSXBase.HTMLAttributes<HTMLMyComponentElement>;
        }
    }
}
"
`;

exports[`generateAppTypes > custom event types > should generate a type declaration file with multiple components using the same custom event type 1`] = `
"/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/runtime";
import { UserImplementedEventType } from "./some/stubbed/path/resources";
export { UserImplementedEventType } from "./some/stubbed/path/resources";
export namespace Components {
    /**
     * docs
     */
    interface MyComponent {
    }
    /**
     * docs
     */
    interface MyNewComponent {
    }
}
export interface MyComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMyComponentElement;
}
export interface MyNewComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMyNewComponentElement;
}
declare global {
    interface HTMLMyComponentElementEventMap {
        "myEvent": UserImplementedEventType;
    }
    /**
     * docs
     */
    interface HTMLMyComponentElement extends Components.MyComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMyComponentElementEventMap>(type: K, listener: (this: HTMLMyComponentElement, ev: MyComponentCustomEvent<HTMLMyComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMyComponentElementEventMap>(type: K, listener: (this: HTMLMyComponentElement, ev: MyComponentCustomEvent<HTMLMyComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMyComponentElement: {
        prototype: HTMLMyComponentElement;
        new (): HTMLMyComponentElement;
    };
    interface HTMLMyNewComponentElementEventMap {
        "myEvent": UserImplementedEventType;
    }
    /**
     * docs
     */
    interface HTMLMyNewComponentElement extends Components.MyNewComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMyNewComponentElementEventMap>(type: K, listener: (this: HTMLMyNewComponentElement, ev: MyNewComponentCustomEvent<HTMLMyNewComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMyNewComponentElementEventMap>(type: K, listener: (this: HTMLMyNewComponentElement, ev: MyNewComponentCustomEvent<HTMLMyNewComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMyNewComponentElement: {
        prototype: HTMLMyNewComponentElement;
        new (): HTMLMyNewComponentElement;
    };
    interface HTMLElementTagNameMap {
        "my-component": HTMLMyComponentElement;
        "my-new-component": HTMLMyNewComponentElement;
    }
}
declare namespace LocalJSX {
    /**
     * docs
     */
    interface MyComponent {
        "onMyEvent"?: (event: MyComponentCustomEvent<UserImplementedEventType>) => void;
    }
    /**
     * docs
     */
    interface MyNewComponent {
        "onMyEvent"?: (event: MyNewComponentCustomEvent<UserImplementedEventType>) => void;
    }
    interface IntrinsicElements {
        "my-component": MyComponent;
        "my-new-component": MyNewComponent;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * docs
             */
            "my-component": LocalJSX.IntrinsicElements["my-component"] & JSXBase.HTMLAttributes<HTMLMyComponentElement>;
            /**
             * docs
             */
            "my-new-component": LocalJSX.IntrinsicElements["my-new-component"] & JSXBase.HTMLAttributes<HTMLMyNewComponentElement>;
        }
    }
}
"
`;

exports[`generateAppTypes > custom event types > should generate a type declaration file with multiple custom events from the same location 1`] = `
"/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/runtime";
import { SecondUserImplementedEventType, UserImplementedEventType } from "./some/stubbed/path/resources";
export { SecondUserImplementedEventType, UserImplementedEventType } from "./some/stubbed/path/resources";
export namespace Components {
    /**
     * docs
     */
    interface MyComponent {
    }
}
export interface MyComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMyComponentElement;
}
declare global {
    interface HTMLMyComponentElementEventMap {
        "myEvent": UserImplementedEventType;
        "mySecondEvent": SecondUserImplementedEventType;
    }
    /**
     * docs
     */
    interface HTMLMyComponentElement extends Components.MyComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMyComponentElementEventMap>(type: K, listener: (this: HTMLMyComponentElement, ev: MyComponentCustomEvent<HTMLMyComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMyComponentElementEventMap>(type: K, listener: (this: HTMLMyComponentElement, ev: MyComponentCustomEvent<HTMLMyComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMyComponentElement: {
        prototype: HTMLMyComponentElement;
        new (): HTMLMyComponentElement;
    };
    interface HTMLElementTagNameMap {
        "my-component": HTMLMyComponentElement;
    }
}
declare namespace LocalJSX {
    /**
     * docs
     */
    interface MyComponent {
        "onMyEvent"?: (event: MyComponentCustomEvent<UserImplementedEventType>) => void;
        "onMySecondEvent"?: (event: MyComponentCustomEvent<SecondUserImplementedEventType>) => void;
    }
    interface IntrinsicElements {
        "my-component": MyComponent;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * docs
             */
            "my-component": LocalJSX.IntrinsicElements["my-component"] & JSXBase.HTMLAttributes<HTMLMyComponentElement>;
        }
    }
}
"
`;

exports[`generateAppTypes > custom event types > should handle custom event type name collisions when defined in separate files 1`] = `
"/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/runtime";
import { UserImplementedEventType } from "./some/stubbed/path/a/resources";
import { UserImplementedEventType as UserImplementedEventType1 } from "./some/stubbed/path/b/resources";
export { UserImplementedEventType } from "./some/stubbed/path/a/resources";
export { UserImplementedEventType as UserImplementedEventType1 } from "./some/stubbed/path/b/resources";
export namespace Components {
    /**
     * docs
     */
    interface MyComponent {
    }
    /**
     * docs
     */
    interface MyNewComponent {
    }
}
export interface MyComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMyComponentElement;
}
export interface MyNewComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMyNewComponentElement;
}
declare global {
    interface HTMLMyComponentElementEventMap {
        "myEvent": UserImplementedEventType;
    }
    /**
     * docs
     */
    interface HTMLMyComponentElement extends Components.MyComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMyComponentElementEventMap>(type: K, listener: (this: HTMLMyComponentElement, ev: MyComponentCustomEvent<HTMLMyComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMyComponentElementEventMap>(type: K, listener: (this: HTMLMyComponentElement, ev: MyComponentCustomEvent<HTMLMyComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMyComponentElement: {
        prototype: HTMLMyComponentElement;
        new (): HTMLMyComponentElement;
    };
    interface HTMLMyNewComponentElementEventMap {
        "myEvent": UserImplementedEventType1;
    }
    /**
     * docs
     */
    interface HTMLMyNewComponentElement extends Components.MyNewComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMyNewComponentElementEventMap>(type: K, listener: (this: HTMLMyNewComponentElement, ev: MyNewComponentCustomEvent<HTMLMyNewComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMyNewComponentElementEventMap>(type: K, listener: (this: HTMLMyNewComponentElement, ev: MyNewComponentCustomEvent<HTMLMyNewComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMyNewComponentElement: {
        prototype: HTMLMyNewComponentElement;
        new (): HTMLMyNewComponentElement;
    };
    interface HTMLElementTagNameMap {
        "my-component": HTMLMyComponentElement;
        "my-new-component": HTMLMyNewComponentElement;
    }
}
declare namespace LocalJSX {
    /**
     * docs
     */
    interface MyComponent {
        "onMyEvent"?: (event: MyComponentCustomEvent<UserImplementedEventType>) => void;
    }
    /**
     * docs
     */
    interface MyNewComponent {
        "onMyEvent"?: (event: MyNewComponentCustomEvent<UserImplementedEventType1>) => void;
    }
    interface IntrinsicElements {
        "my-component": MyComponent;
        "my-new-component": MyNewComponent;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * docs
             */
            "my-component": LocalJSX.IntrinsicElements["my-component"] & JSXBase.HTMLAttributes<HTMLMyComponentElement>;
            /**
             * docs
             */
            "my-new-component": LocalJSX.IntrinsicElements["my-new-component"] & JSXBase.HTMLAttributes<HTMLMyNewComponentElement>;
        }
    }
}
"
`;

exports[`generateAppTypes > custom event types > should handle custom event type name collisions when defined in the component files 1`] = `
"/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/runtime";
import { UserImplementedEventType } from "./some/stubbed/path/a/my-component";
import { UserImplementedEventType as UserImplementedEventType1 } from "./some/stubbed/path/b/my-new-component";
export { UserImplementedEventType } from "./some/stubbed/path/a/my-component";
export { UserImplementedEventType as UserImplementedEventType1 } from "./some/stubbed/path/b/my-new-component";
export namespace Components {
    /**
     * docs
     */
    interface MyComponent {
    }
    /**
     * docs
     */
    interface MyNewComponent {
    }
}
export interface MyComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMyComponentElement;
}
export interface MyNewComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMyNewComponentElement;
}
declare global {
    interface HTMLMyComponentElementEventMap {
        "myEvent": UserImplementedEventType;
    }
    /**
     * docs
     */
    interface HTMLMyComponentElement extends Components.MyComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMyComponentElementEventMap>(type: K, listener: (this: HTMLMyComponentElement, ev: MyComponentCustomEvent<HTMLMyComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMyComponentElementEventMap>(type: K, listener: (this: HTMLMyComponentElement, ev: MyComponentCustomEvent<HTMLMyComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMyComponentElement: {
        prototype: HTMLMyComponentElement;
        new (): HTMLMyComponentElement;
    };
    interface HTMLMyNewComponentElementEventMap {
        "myEvent": UserImplementedEventType1;
    }
    /**
     * docs
     */
    interface HTMLMyNewComponentElement extends Components.MyNewComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMyNewComponentElementEventMap>(type: K, listener: (this: HTMLMyNewComponentElement, ev: MyNewComponentCustomEvent<HTMLMyNewComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMyNewComponentElementEventMap>(type: K, listener: (this: HTMLMyNewComponentElement, ev: MyNewComponentCustomEvent<HTMLMyNewComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMyNewComponentElement: {
        prototype: HTMLMyNewComponentElement;
        new (): HTMLMyNewComponentElement;
    };
    interface HTMLElementTagNameMap {
        "my-component": HTMLMyComponentElement;
        "my-new-component": HTMLMyNewComponentElement;
    }
}
declare namespace LocalJSX {
    /**
     * docs
     */
    interface MyComponent {
        "onMyEvent"?: (event: MyComponentCustomEvent<UserImplementedEventType>) => void;
    }
    /**
     * docs
     */
    interface MyNewComponent {
        "onMyEvent"?: (event: MyNewComponentCustomEvent<UserImplementedEventType1>) => void;
    }
    interface IntrinsicElements {
        "my-component": MyComponent;
        "my-new-component": MyNewComponent;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * docs
             */
            "my-component": LocalJSX.IntrinsicElements["my-component"] & JSXBase.HTMLAttributes<HTMLMyComponentElement>;
            /**
             * docs
             */
            "my-new-component": LocalJSX.IntrinsicElements["my-new-component"] & JSXBase.HTMLAttributes<HTMLMyNewComponentElement>;
        }
    }
}
"
`;

exports[`generateAppTypes > custom prop types > should export prop types too 1`] = `
"/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/runtime";
import { UserImplementedPropType } from "./some/stubbed/path/resources";
export { UserImplementedPropType } from "./some/stubbed/path/resources";
export namespace Components {
    /**
     * docs
     */
    interface MyComponent {
        "name": UserImplementedPropType;
    }
}
declare global {
    /**
     * docs
     */
    interface HTMLMyComponentElement extends Components.MyComponent, HTMLStencilElement {
    }
    var HTMLMyComponentElement: {
        prototype: HTMLMyComponentElement;
        new (): HTMLMyComponentElement;
    };
    interface HTMLElementTagNameMap {
        "my-component": HTMLMyComponentElement;
    }
}
declare namespace LocalJSX {
    /**
     * docs
     */
    interface MyComponent {
        "name"?: UserImplementedPropType;
    }

    interface MyComponentAttributes {
        "name": UserImplementedPropType;
    }

    interface IntrinsicElements {
        "my-component": Omit<MyComponent, keyof MyComponentAttributes> & { [K in keyof MyComponent & keyof MyComponentAttributes]?: MyComponent[K] } & { [K in keyof MyComponent & keyof MyComponentAttributes as \`attr:\${K}\`]?: MyComponentAttributes[K] } & { [K in keyof MyComponent & keyof MyComponentAttributes as \`prop:\${K}\`]?: MyComponent[K] };
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * docs
             */
            "my-component": LocalJSX.IntrinsicElements["my-component"] & JSXBase.HTMLAttributes<HTMLMyComponentElement>;
        }
    }
}
"
`;

exports[`generateAppTypes > custom prop types > should generate a type declaration file with multiple components using the same custom prop type 1`] = `
"/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/runtime";
import { UserImplementedPropType } from "./some/stubbed/path/resources";
export { UserImplementedPropType } from "./some/stubbed/path/resources";
export namespace Components {
    /**
     * docs
     */
    interface MyComponent {
        "name": UserImplementedPropType;
    }
    /**
     * docs
     */
    interface MyNewComponent {
        "fullName": UserImplementedPropType;
    }
}
declare global {
    /**
     * docs
     */
    interface HTMLMyComponentElement extends Components.MyComponent, HTMLStencilElement {
    }
    var HTMLMyComponentElement: {
        prototype: HTMLMyComponentElement;
        new (): HTMLMyComponentElement;
    };
    /**
     * docs
     */
    interface HTMLMyNewComponentElement extends Components.MyNewComponent, HTMLStencilElement {
    }
    var HTMLMyNewComponentElement: {
        prototype: HTMLMyNewComponentElement;
        new (): HTMLMyNewComponentElement;
    };
    interface HTMLElementTagNameMap {
        "my-component": HTMLMyComponentElement;
        "my-new-component": HTMLMyNewComponentElement;
    }
}
declare namespace LocalJSX {
    /**
     * docs
     */
    interface MyComponent {
        "name"?: UserImplementedPropType;
    }
    /**
     * docs
     */
    interface MyNewComponent {
        "fullName"?: UserImplementedPropType;
    }

    interface MyComponentAttributes {
        "name": UserImplementedPropType;
    }
    interface MyNewComponentAttributes {
        "fullName": UserImplementedPropType;
    }

    interface IntrinsicElements {
        "my-component": Omit<MyComponent, keyof MyComponentAttributes> & { [K in keyof MyComponent & keyof MyComponentAttributes]?: MyComponent[K] } & { [K in keyof MyComponent & keyof MyComponentAttributes as \`attr:\${K}\`]?: MyComponentAttributes[K] } & { [K in keyof MyComponent & keyof MyComponentAttributes as \`prop:\${K}\`]?: MyComponent[K] };
        "my-new-component": Omit<MyNewComponent, keyof MyNewComponentAttributes> & { [K in keyof MyNewComponent & keyof MyNewComponentAttributes]?: MyNewComponent[K] } & { [K in keyof MyNewComponent & keyof MyNewComponentAttributes as \`attr:\${K}\`]?: MyNewComponentAttributes[K] } & { [K in keyof MyNewComponent & keyof MyNewComponentAttributes as \`prop:\${K}\`]?: MyNewComponent[K] };
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * docs
             */
            "my-component": LocalJSX.IntrinsicElements["my-component"] & JSXBase.HTMLAttributes<HTMLMyComponentElement>;
            /**
             * docs
             */
            "my-new-component": LocalJSX.IntrinsicElements["my-new-component"] & JSXBase.HTMLAttributes<HTMLMyNewComponentElement>;
        }
    }
}
"
`;

exports[`generateAppTypes > custom prop types > should generate a type declaration file with multiple custom prop types from the same location 1`] = `
"/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/runtime";
import { SecondUserImplementedPropType, UserImplementedPropType } from "./some/stubbed/path/resources";
export { SecondUserImplementedPropType, UserImplementedPropType } from "./some/stubbed/path/resources";
export namespace Components {
    /**
     * docs
     */
    interface MyComponent {
        "email": SecondUserImplementedPropType;
        "name": UserImplementedPropType;
    }
}
declare global {
    /**
     * docs
     */
    interface HTMLMyComponentElement extends Components.MyComponent, HTMLStencilElement {
    }
    var HTMLMyComponentElement: {
        prototype: HTMLMyComponentElement;
        new (): HTMLMyComponentElement;
    };
    interface HTMLElementTagNameMap {
        "my-component": HTMLMyComponentElement;
    }
}
declare namespace LocalJSX {
    /**
     * docs
     */
    interface MyComponent {
        "email"?: SecondUserImplementedPropType;
        "name"?: UserImplementedPropType;
    }

    interface MyComponentAttributes {
        "name": UserImplementedPropType;
        "email": SecondUserImplementedPropType;
    }

    interface IntrinsicElements {
        "my-component": Omit<MyComponent, keyof MyComponentAttributes> & { [K in keyof MyComponent & keyof MyComponentAttributes]?: MyComponent[K] } & { [K in keyof MyComponent & keyof MyComponentAttributes as \`attr:\${K}\`]?: MyComponentAttributes[K] } & { [K in keyof MyComponent & keyof MyComponentAttributes as \`prop:\${K}\`]?: MyComponent[K] };
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * docs
             */
            "my-component": LocalJSX.IntrinsicElements["my-component"] & JSXBase.HTMLAttributes<HTMLMyComponentElement>;
        }
    }
}
"
`;

exports[`generateAppTypes > custom prop types > should handle custom prop type name collisions when defined in separate files 1`] = `
"/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/runtime";
import { UserImplementedPropType } from "./some/stubbed/path/a/resources";
import { UserImplementedPropType as UserImplementedPropType1 } from "./some/stubbed/path/b/resources";
export { UserImplementedPropType } from "./some/stubbed/path/a/resources";
export { UserImplementedPropType as UserImplementedPropType1 } from "./some/stubbed/path/b/resources";
export namespace Components {
    /**
     * docs
     */
    interface MyComponent {
        "name": UserImplementedPropType;
    }
    /**
     * docs
     */
    interface MyNewComponent {
        "newName": UserImplementedPropType1;
    }
}
declare global {
    /**
     * docs
     */
    interface HTMLMyComponentElement extends Components.MyComponent, HTMLStencilElement {
    }
    var HTMLMyComponentElement: {
        prototype: HTMLMyComponentElement;
        new (): HTMLMyComponentElement;
    };
    /**
     * docs
     */
    interface HTMLMyNewComponentElement extends Components.MyNewComponent, HTMLStencilElement {
    }
    var HTMLMyNewComponentElement: {
        prototype: HTMLMyNewComponentElement;
        new (): HTMLMyNewComponentElement;
    };
    interface HTMLElementTagNameMap {
        "my-component": HTMLMyComponentElement;
        "my-new-component": HTMLMyNewComponentElement;
    }
}
declare namespace LocalJSX {
    /**
     * docs
     */
    interface MyComponent {
        "name"?: UserImplementedPropType;
    }
    /**
     * docs
     */
    interface MyNewComponent {
        "newName"?: UserImplementedPropType1;
    }

    interface MyComponentAttributes {
        "name": UserImplementedPropType;
    }
    interface MyNewComponentAttributes {
        "newName": UserImplementedPropType;
    }

    interface IntrinsicElements {
        "my-component": Omit<MyComponent, keyof MyComponentAttributes> & { [K in keyof MyComponent & keyof MyComponentAttributes]?: MyComponent[K] } & { [K in keyof MyComponent & keyof MyComponentAttributes as \`attr:\${K}\`]?: MyComponentAttributes[K] } & { [K in keyof MyComponent & keyof MyComponentAttributes as \`prop:\${K}\`]?: MyComponent[K] };
        "my-new-component": Omit<MyNewComponent, keyof MyNewComponentAttributes> & { [K in keyof MyNewComponent & keyof MyNewComponentAttributes]?: MyNewComponent[K] } & { [K in keyof MyNewComponent & keyof MyNewComponentAttributes as \`attr:\${K}\`]?: MyNewComponentAttributes[K] } & { [K in keyof MyNewComponent & keyof MyNewComponentAttributes as \`prop:\${K}\`]?: MyNewComponent[K] };
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * docs
             */
            "my-component": LocalJSX.IntrinsicElements["my-component"] & JSXBase.HTMLAttributes<HTMLMyComponentElement>;
            /**
             * docs
             */
            "my-new-component": LocalJSX.IntrinsicElements["my-new-component"] & JSXBase.HTMLAttributes<HTMLMyNewComponentElement>;
        }
    }
}
"
`;

exports[`generateAppTypes > custom prop types > should handle custom prop type name collisions when defined in the component files 1`] = `
"/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/runtime";
import { UserImplementedPropType } from "./some/stubbed/path/a/my-component";
import { UserImplementedPropType as UserImplementedPropType1 } from "./some/stubbed/path/b/my-new-component";
export { UserImplementedPropType } from "./some/stubbed/path/a/my-component";
export { UserImplementedPropType as UserImplementedPropType1 } from "./some/stubbed/path/b/my-new-component";
export namespace Components {
    /**
     * docs
     */
    interface MyComponent {
        "name": UserImplementedPropType;
    }
    /**
     * docs
     */
    interface MyNewComponent {
        "name": UserImplementedPropType1;
    }
}
declare global {
    /**
     * docs
     */
    interface HTMLMyComponentElement extends Components.MyComponent, HTMLStencilElement {
    }
    var HTMLMyComponentElement: {
        prototype: HTMLMyComponentElement;
        new (): HTMLMyComponentElement;
    };
    /**
     * docs
     */
    interface HTMLMyNewComponentElement extends Components.MyNewComponent, HTMLStencilElement {
    }
    var HTMLMyNewComponentElement: {
        prototype: HTMLMyNewComponentElement;
        new (): HTMLMyNewComponentElement;
    };
    interface HTMLElementTagNameMap {
        "my-component": HTMLMyComponentElement;
        "my-new-component": HTMLMyNewComponentElement;
    }
}
declare namespace LocalJSX {
    /**
     * docs
     */
    interface MyComponent {
        "name"?: UserImplementedPropType;
    }
    /**
     * docs
     */
    interface MyNewComponent {
        "name"?: UserImplementedPropType1;
    }

    interface MyComponentAttributes {
        "name": UserImplementedPropType;
    }
    interface MyNewComponentAttributes {
        "name": UserImplementedPropType;
    }

    interface IntrinsicElements {
        "my-component": Omit<MyComponent, keyof MyComponentAttributes> & { [K in keyof MyComponent & keyof MyComponentAttributes]?: MyComponent[K] } & { [K in keyof MyComponent & keyof MyComponentAttributes as \`attr:\${K}\`]?: MyComponentAttributes[K] } & { [K in keyof MyComponent & keyof MyComponentAttributes as \`prop:\${K}\`]?: MyComponent[K] };
        "my-new-component": Omit<MyNewComponent, keyof MyNewComponentAttributes> & { [K in keyof MyNewComponent & keyof MyNewComponentAttributes]?: MyNewComponent[K] } & { [K in keyof MyNewComponent & keyof MyNewComponentAttributes as \`attr:\${K}\`]?: MyNewComponentAttributes[K] } & { [K in keyof MyNewComponent & keyof MyNewComponentAttributes as \`prop:\${K}\`]?: MyNewComponent[K] };
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * docs
             */
            "my-component": LocalJSX.IntrinsicElements["my-component"] & JSXBase.HTMLAttributes<HTMLMyComponentElement>;
            /**
             * docs
             */
            "my-new-component": LocalJSX.IntrinsicElements["my-new-component"] & JSXBase.HTMLAttributes<HTMLMyNewComponentElement>;
        }
    }
}
"
`;

exports[`generateAppTypes > should generate a type declaration file without custom types 1`] = `
"/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/runtime";
export namespace Components {
    /**
     * docs
     */
    interface MyComponent {
    }
}
declare global {
    /**
     * docs
     */
    interface HTMLMyComponentElement extends Components.MyComponent, HTMLStencilElement {
    }
    var HTMLMyComponentElement: {
        prototype: HTMLMyComponentElement;
        new (): HTMLMyComponentElement;
    };
    interface HTMLElementTagNameMap {
        "my-component": HTMLMyComponentElement;
    }
}
declare namespace LocalJSX {
    /**
     * docs
     */
    interface MyComponent {
    }
    interface IntrinsicElements {
        "my-component": MyComponent;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * docs
             */
            "my-component": LocalJSX.IntrinsicElements["my-component"] & JSXBase.HTMLAttributes<HTMLMyComponentElement>;
        }
    }
}
"
`;

exports[`generateAppTypes > should handle type import aliases 1`] = `
"/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/runtime";
import { MyType as UserImplementedPropType } from "@utils";
import { Fragment } from "@stencil/core";
export { MyType as UserImplementedPropType } from "@utils";
export { Fragment } from "@stencil/core";
export namespace Components {
    /**
     * docs
     */
    interface MyComponent {
        "name": UserImplementedPropType;
    }
}
declare global {
    /**
     * docs
     */
    interface HTMLMyComponentElement extends Components.MyComponent, HTMLStencilElement {
    }
    var HTMLMyComponentElement: {
        prototype: HTMLMyComponentElement;
        new (): HTMLMyComponentElement;
    };
    interface HTMLElementTagNameMap {
        "my-component": HTMLMyComponentElement;
    }
}
declare namespace LocalJSX {
    /**
     * docs
     */
    interface MyComponent {
        "name"?: UserImplementedPropType;
    }

    interface MyComponentAttributes {
        "name": UserImplementedPropType;
    }

    interface IntrinsicElements {
        "my-component": Omit<MyComponent, keyof MyComponentAttributes> & { [K in keyof MyComponent & keyof MyComponentAttributes]?: MyComponent[K] } & { [K in keyof MyComponent & keyof MyComponentAttributes as \`attr:\${K}\`]?: MyComponentAttributes[K] } & { [K in keyof MyComponent & keyof MyComponentAttributes as \`prop:\${K}\`]?: MyComponent[K] };
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * docs
             */
            "my-component": LocalJSX.IntrinsicElements["my-component"] & JSXBase.HTMLAttributes<HTMLMyComponentElement>;
        }
    }
}
"
`;

exports[`generateAppTypes > should not transform aliased paths if transformAliasedImportPaths is false 1`] = `
"/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/runtime";
import { UserImplementedPropType } from "@utils";
export { UserImplementedPropType } from "@utils";
export namespace Components {
    /**
     * docs
     */
    interface MyComponent {
        "name": UserImplementedPropType;
    }
}
declare global {
    /**
     * docs
     */
    interface HTMLMyComponentElement extends Components.MyComponent, HTMLStencilElement {
    }
    var HTMLMyComponentElement: {
        prototype: HTMLMyComponentElement;
        new (): HTMLMyComponentElement;
    };
    interface HTMLElementTagNameMap {
        "my-component": HTMLMyComponentElement;
    }
}
declare namespace LocalJSX {
    /**
     * docs
     */
    interface MyComponent {
        "name"?: UserImplementedPropType;
    }

    interface MyComponentAttributes {
        "name": UserImplementedPropType;
    }

    interface IntrinsicElements {
        "my-component": Omit<MyComponent, keyof MyComponentAttributes> & { [K in keyof MyComponent & keyof MyComponentAttributes]?: MyComponent[K] } & { [K in keyof MyComponent & keyof MyComponentAttributes as \`attr:\${K}\`]?: MyComponentAttributes[K] } & { [K in keyof MyComponent & keyof MyComponentAttributes as \`prop:\${K}\`]?: MyComponent[K] };
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * docs
             */
            "my-component": LocalJSX.IntrinsicElements["my-component"] & JSXBase.HTMLAttributes<HTMLMyComponentElement>;
        }
    }
}
"
`;

exports[`generateAppTypes > should transform aliased paths if transformAliasedImportPaths is true 1`] = `
"/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/runtime";
import { UserImplementedPropType } from "./some/stubbed/path/utils/utils";
export { UserImplementedPropType } from "./some/stubbed/path/utils/utils";
export namespace Components {
    /**
     * docs
     */
    interface MyComponent {
        "name": UserImplementedPropType;
    }
}
declare global {
    /**
     * docs
     */
    interface HTMLMyComponentElement extends Components.MyComponent, HTMLStencilElement {
    }
    var HTMLMyComponentElement: {
        prototype: HTMLMyComponentElement;
        new (): HTMLMyComponentElement;
    };
    interface HTMLElementTagNameMap {
        "my-component": HTMLMyComponentElement;
    }
}
declare namespace LocalJSX {
    /**
     * docs
     */
    interface MyComponent {
        "name"?: UserImplementedPropType;
    }

    interface MyComponentAttributes {
        "name": UserImplementedPropType;
    }

    interface IntrinsicElements {
        "my-component": Omit<MyComponent, keyof MyComponentAttributes> & { [K in keyof MyComponent & keyof MyComponentAttributes]?: MyComponent[K] } & { [K in keyof MyComponent & keyof MyComponentAttributes as \`attr:\${K}\`]?: MyComponentAttributes[K] } & { [K in keyof MyComponent & keyof MyComponentAttributes as \`prop:\${K}\`]?: MyComponent[K] };
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * docs
             */
            "my-component": LocalJSX.IntrinsicElements["my-component"] & JSXBase.HTMLAttributes<HTMLMyComponentElement>;
        }
    }
}
"
`;

exports[`generateAppTypes > should work with both event and prop types 1`] = `
"/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/runtime";
import { UserImplementedEventType, UserImplementedPropType } from "./some/stubbed/path/a/resources";
export { UserImplementedEventType, UserImplementedPropType } from "./some/stubbed/path/a/resources";
export namespace Components {
    /**
     * docs
     */
    interface MyComponent {
        "name": UserImplementedPropType;
    }
}
export interface MyComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMyComponentElement;
}
declare global {
    interface HTMLMyComponentElementEventMap {
        "myEvent": UserImplementedEventType;
    }
    /**
     * docs
     */
    interface HTMLMyComponentElement extends Components.MyComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMyComponentElementEventMap>(type: K, listener: (this: HTMLMyComponentElement, ev: MyComponentCustomEvent<HTMLMyComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMyComponentElementEventMap>(type: K, listener: (this: HTMLMyComponentElement, ev: MyComponentCustomEvent<HTMLMyComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMyComponentElement: {
        prototype: HTMLMyComponentElement;
        new (): HTMLMyComponentElement;
    };
    interface HTMLElementTagNameMap {
        "my-component": HTMLMyComponentElement;
    }
}
declare namespace LocalJSX {
    /**
     * docs
     */
    interface MyComponent {
        "name"?: UserImplementedPropType;
        "onMyEvent"?: (event: MyComponentCustomEvent<UserImplementedEventType>) => void;
    }

    interface MyComponentAttributes {
        "name": UserImplementedPropType;
    }

    interface IntrinsicElements {
        "my-component": Omit<MyComponent, keyof MyComponentAttributes> & { [K in keyof MyComponent & keyof MyComponentAttributes]?: MyComponent[K] } & { [K in keyof MyComponent & keyof MyComponentAttributes as \`attr:\${K}\`]?: MyComponentAttributes[K] } & { [K in keyof MyComponent & keyof MyComponentAttributes as \`prop:\${K}\`]?: MyComponent[K] };
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * docs
             */
            "my-component": LocalJSX.IntrinsicElements["my-component"] & JSXBase.HTMLAttributes<HTMLMyComponentElement>;
        }
    }
}
"
`;
